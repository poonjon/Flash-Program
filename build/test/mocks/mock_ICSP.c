/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "mock_ICSP.h"

typedef struct _CMOCK_writeICSP_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint16 Expected_commandByte;
  uint16 Expected_dataBytes;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_writeICSP_CALL_INSTANCE;

typedef struct _CMOCK_writeBit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint16 Expected_bitToWrite;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_writeBit_CALL_INSTANCE;

typedef struct _CMOCK_writeBits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint16 Expected_pattern;
  uint16 Expected_bitsToWrite;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_writeBits_CALL_INSTANCE;

typedef struct _CMOCK_readICSP_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint16 ReturnVal;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_readICSP_CALL_INSTANCE;

typedef struct _CMOCK_readFirstByte_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint16 ReturnVal;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_readFirstByte_CALL_INSTANCE;

typedef struct _CMOCK_readBit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint16 ReturnVal;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_readBit_CALL_INSTANCE;

typedef struct _CMOCK_readBits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint16 ReturnVal;
  int CallOrder;
  int Expected_bitsToRead;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_readBits_CALL_INSTANCE;

static struct mock_ICSPInstance
{
  int writeICSP_IgnoreBool;
  CMOCK_writeICSP_CALLBACK writeICSP_CallbackFunctionPointer;
  int writeICSP_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE writeICSP_CallInstance;
  int writeBit_IgnoreBool;
  CMOCK_writeBit_CALLBACK writeBit_CallbackFunctionPointer;
  int writeBit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE writeBit_CallInstance;
  int writeBits_IgnoreBool;
  CMOCK_writeBits_CALLBACK writeBits_CallbackFunctionPointer;
  int writeBits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE writeBits_CallInstance;
  int readICSP_IgnoreBool;
  uint16 readICSP_FinalReturn;
  CMOCK_readICSP_CALLBACK readICSP_CallbackFunctionPointer;
  int readICSP_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE readICSP_CallInstance;
  int readFirstByte_IgnoreBool;
  uint16 readFirstByte_FinalReturn;
  CMOCK_readFirstByte_CALLBACK readFirstByte_CallbackFunctionPointer;
  int readFirstByte_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE readFirstByte_CallInstance;
  int readBit_IgnoreBool;
  uint16 readBit_FinalReturn;
  CMOCK_readBit_CALLBACK readBit_CallbackFunctionPointer;
  int readBit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE readBit_CallInstance;
  int readBits_IgnoreBool;
  uint16 readBits_FinalReturn;
  CMOCK_readBits_CALLBACK readBits_CallbackFunctionPointer;
  int readBits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE readBits_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_ICSP_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.writeICSP_IgnoreBool)
    Mock.writeICSP_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.writeICSP_CallInstance, cmock_line, "Function 'writeICSP' called less times than expected.");
  if (Mock.writeICSP_CallbackFunctionPointer != NULL)
    Mock.writeICSP_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.writeBit_IgnoreBool)
    Mock.writeBit_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.writeBit_CallInstance, cmock_line, "Function 'writeBit' called less times than expected.");
  if (Mock.writeBit_CallbackFunctionPointer != NULL)
    Mock.writeBit_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.writeBits_IgnoreBool)
    Mock.writeBits_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.writeBits_CallInstance, cmock_line, "Function 'writeBits' called less times than expected.");
  if (Mock.writeBits_CallbackFunctionPointer != NULL)
    Mock.writeBits_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.readICSP_IgnoreBool)
    Mock.readICSP_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.readICSP_CallInstance, cmock_line, "Function 'readICSP' called less times than expected.");
  if (Mock.readICSP_CallbackFunctionPointer != NULL)
    Mock.readICSP_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.readFirstByte_IgnoreBool)
    Mock.readFirstByte_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.readFirstByte_CallInstance, cmock_line, "Function 'readFirstByte' called less times than expected.");
  if (Mock.readFirstByte_CallbackFunctionPointer != NULL)
    Mock.readFirstByte_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.readBit_IgnoreBool)
    Mock.readBit_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.readBit_CallInstance, cmock_line, "Function 'readBit' called less times than expected.");
  if (Mock.readBit_CallbackFunctionPointer != NULL)
    Mock.readBit_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.readBits_IgnoreBool)
    Mock.readBits_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.readBits_CallInstance, cmock_line, "Function 'readBits' called less times than expected.");
  if (Mock.readBits_CallbackFunctionPointer != NULL)
    Mock.readBits_CallInstance = CMOCK_GUTS_NONE;
}

void mock_ICSP_Init(void)
{
  mock_ICSP_Destroy();
}

void mock_ICSP_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.writeICSP_CallbackFunctionPointer = NULL;
  Mock.writeICSP_CallbackCalls = 0;
  Mock.writeBit_CallbackFunctionPointer = NULL;
  Mock.writeBit_CallbackCalls = 0;
  Mock.writeBits_CallbackFunctionPointer = NULL;
  Mock.writeBits_CallbackCalls = 0;
  Mock.readICSP_CallbackFunctionPointer = NULL;
  Mock.readICSP_CallbackCalls = 0;
  Mock.readFirstByte_CallbackFunctionPointer = NULL;
  Mock.readFirstByte_CallbackCalls = 0;
  Mock.readBit_CallbackFunctionPointer = NULL;
  Mock.readBit_CallbackCalls = 0;
  Mock.readBits_CallbackFunctionPointer = NULL;
  Mock.readBits_CallbackCalls = 0;
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

void writeICSP(uint16 commandByte, uint16 dataBytes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_writeICSP_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeICSP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.writeICSP_CallInstance);
  Mock.writeICSP_CallInstance = CMock_Guts_MemNext(Mock.writeICSP_CallInstance);
  if (Mock.writeICSP_IgnoreBool)
  {
    return;
  }
  if (Mock.writeICSP_CallbackFunctionPointer != NULL)
  {
    Mock.writeICSP_CallbackFunctionPointer(commandByte, dataBytes, Mock.writeICSP_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'writeICSP' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writeICSP' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writeICSP' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_commandByte, commandByte, cmock_line, "Function 'writeICSP' called with unexpected value for argument 'commandByte'.");
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_dataBytes, dataBytes, cmock_line, "Function 'writeICSP' called with unexpected value for argument 'dataBytes'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_writeICSP(CMOCK_writeICSP_CALL_INSTANCE* cmock_call_instance, uint16 commandByte, uint16 dataBytes)
{
  cmock_call_instance->Expected_commandByte = commandByte;
  cmock_call_instance->Expected_dataBytes = dataBytes;
}

void writeICSP_CMockIgnore(void)
{
  Mock.writeICSP_IgnoreBool = (int)1;
}

void writeICSP_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16 commandByte, uint16 dataBytes)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writeICSP_CALL_INSTANCE));
  CMOCK_writeICSP_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeICSP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writeICSP_CallInstance = CMock_Guts_MemChain(Mock.writeICSP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writeICSP(cmock_call_instance, commandByte, dataBytes);
}

void writeICSP_StubWithCallback(CMOCK_writeICSP_CALLBACK Callback)
{
  Mock.writeICSP_CallbackFunctionPointer = Callback;
}

void writeICSP_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint16 commandByte, uint16 dataBytes, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writeICSP_CALL_INSTANCE));
  CMOCK_writeICSP_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeICSP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writeICSP_CallInstance = CMock_Guts_MemChain(Mock.writeICSP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writeICSP(cmock_call_instance, commandByte, dataBytes);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void writeBit(uint16 bitToWrite)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_writeBit_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeBit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.writeBit_CallInstance);
  Mock.writeBit_CallInstance = CMock_Guts_MemNext(Mock.writeBit_CallInstance);
  if (Mock.writeBit_IgnoreBool)
  {
    return;
  }
  if (Mock.writeBit_CallbackFunctionPointer != NULL)
  {
    Mock.writeBit_CallbackFunctionPointer(bitToWrite, Mock.writeBit_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'writeBit' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writeBit' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writeBit' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_bitToWrite, bitToWrite, cmock_line, "Function 'writeBit' called with unexpected value for argument 'bitToWrite'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_writeBit(CMOCK_writeBit_CALL_INSTANCE* cmock_call_instance, uint16 bitToWrite)
{
  cmock_call_instance->Expected_bitToWrite = bitToWrite;
}

void writeBit_CMockIgnore(void)
{
  Mock.writeBit_IgnoreBool = (int)1;
}

void writeBit_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16 bitToWrite)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writeBit_CALL_INSTANCE));
  CMOCK_writeBit_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeBit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writeBit_CallInstance = CMock_Guts_MemChain(Mock.writeBit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writeBit(cmock_call_instance, bitToWrite);
}

void writeBit_StubWithCallback(CMOCK_writeBit_CALLBACK Callback)
{
  Mock.writeBit_CallbackFunctionPointer = Callback;
}

void writeBit_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint16 bitToWrite, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writeBit_CALL_INSTANCE));
  CMOCK_writeBit_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeBit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writeBit_CallInstance = CMock_Guts_MemChain(Mock.writeBit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writeBit(cmock_call_instance, bitToWrite);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void writeBits(uint16 pattern, uint16 bitsToWrite)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_writeBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.writeBits_CallInstance);
  Mock.writeBits_CallInstance = CMock_Guts_MemNext(Mock.writeBits_CallInstance);
  if (Mock.writeBits_IgnoreBool)
  {
    return;
  }
  if (Mock.writeBits_CallbackFunctionPointer != NULL)
  {
    Mock.writeBits_CallbackFunctionPointer(pattern, bitsToWrite, Mock.writeBits_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'writeBits' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writeBits' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writeBits' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_pattern, pattern, cmock_line, "Function 'writeBits' called with unexpected value for argument 'pattern'.");
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_bitsToWrite, bitsToWrite, cmock_line, "Function 'writeBits' called with unexpected value for argument 'bitsToWrite'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_writeBits(CMOCK_writeBits_CALL_INSTANCE* cmock_call_instance, uint16 pattern, uint16 bitsToWrite)
{
  cmock_call_instance->Expected_pattern = pattern;
  cmock_call_instance->Expected_bitsToWrite = bitsToWrite;
}

void writeBits_CMockIgnore(void)
{
  Mock.writeBits_IgnoreBool = (int)1;
}

void writeBits_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16 pattern, uint16 bitsToWrite)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writeBits_CALL_INSTANCE));
  CMOCK_writeBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writeBits_CallInstance = CMock_Guts_MemChain(Mock.writeBits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writeBits(cmock_call_instance, pattern, bitsToWrite);
}

void writeBits_StubWithCallback(CMOCK_writeBits_CALLBACK Callback)
{
  Mock.writeBits_CallbackFunctionPointer = Callback;
}

void writeBits_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint16 pattern, uint16 bitsToWrite, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writeBits_CALL_INSTANCE));
  CMOCK_writeBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writeBits_CallInstance = CMock_Guts_MemChain(Mock.writeBits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writeBits(cmock_call_instance, pattern, bitsToWrite);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

uint16 readICSP(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_readICSP_CALL_INSTANCE* cmock_call_instance = (CMOCK_readICSP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.readICSP_CallInstance);
  Mock.readICSP_CallInstance = CMock_Guts_MemNext(Mock.readICSP_CallInstance);
  if (Mock.readICSP_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.readICSP_FinalReturn;
    Mock.readICSP_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.readICSP_CallbackFunctionPointer != NULL)
  {
    return Mock.readICSP_CallbackFunctionPointer(Mock.readICSP_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'readICSP' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readICSP' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readICSP' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  return cmock_call_instance->ReturnVal;
}

void readICSP_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readICSP_CALL_INSTANCE));
  CMOCK_readICSP_CALL_INSTANCE* cmock_call_instance = (CMOCK_readICSP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readICSP_CallInstance = CMock_Guts_MemChain(Mock.readICSP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.readICSP_IgnoreBool = (int)1;
}

void readICSP_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readICSP_CALL_INSTANCE));
  CMOCK_readICSP_CALL_INSTANCE* cmock_call_instance = (CMOCK_readICSP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readICSP_CallInstance = CMock_Guts_MemChain(Mock.readICSP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void readICSP_StubWithCallback(CMOCK_readICSP_CALLBACK Callback)
{
  Mock.readICSP_CallbackFunctionPointer = Callback;
}

void readICSP_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readICSP_CALL_INSTANCE));
  CMOCK_readICSP_CALL_INSTANCE* cmock_call_instance = (CMOCK_readICSP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readICSP_CallInstance = CMock_Guts_MemChain(Mock.readICSP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

uint16 readFirstByte(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_readFirstByte_CALL_INSTANCE* cmock_call_instance = (CMOCK_readFirstByte_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.readFirstByte_CallInstance);
  Mock.readFirstByte_CallInstance = CMock_Guts_MemNext(Mock.readFirstByte_CallInstance);
  if (Mock.readFirstByte_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.readFirstByte_FinalReturn;
    Mock.readFirstByte_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.readFirstByte_CallbackFunctionPointer != NULL)
  {
    return Mock.readFirstByte_CallbackFunctionPointer(Mock.readFirstByte_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'readFirstByte' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readFirstByte' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readFirstByte' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  return cmock_call_instance->ReturnVal;
}

void readFirstByte_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readFirstByte_CALL_INSTANCE));
  CMOCK_readFirstByte_CALL_INSTANCE* cmock_call_instance = (CMOCK_readFirstByte_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readFirstByte_CallInstance = CMock_Guts_MemChain(Mock.readFirstByte_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.readFirstByte_IgnoreBool = (int)1;
}

void readFirstByte_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readFirstByte_CALL_INSTANCE));
  CMOCK_readFirstByte_CALL_INSTANCE* cmock_call_instance = (CMOCK_readFirstByte_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readFirstByte_CallInstance = CMock_Guts_MemChain(Mock.readFirstByte_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void readFirstByte_StubWithCallback(CMOCK_readFirstByte_CALLBACK Callback)
{
  Mock.readFirstByte_CallbackFunctionPointer = Callback;
}

void readFirstByte_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readFirstByte_CALL_INSTANCE));
  CMOCK_readFirstByte_CALL_INSTANCE* cmock_call_instance = (CMOCK_readFirstByte_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readFirstByte_CallInstance = CMock_Guts_MemChain(Mock.readFirstByte_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

uint16 readBit(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_readBit_CALL_INSTANCE* cmock_call_instance = (CMOCK_readBit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.readBit_CallInstance);
  Mock.readBit_CallInstance = CMock_Guts_MemNext(Mock.readBit_CallInstance);
  if (Mock.readBit_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.readBit_FinalReturn;
    Mock.readBit_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.readBit_CallbackFunctionPointer != NULL)
  {
    return Mock.readBit_CallbackFunctionPointer(Mock.readBit_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'readBit' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readBit' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readBit' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  return cmock_call_instance->ReturnVal;
}

void readBit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readBit_CALL_INSTANCE));
  CMOCK_readBit_CALL_INSTANCE* cmock_call_instance = (CMOCK_readBit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readBit_CallInstance = CMock_Guts_MemChain(Mock.readBit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.readBit_IgnoreBool = (int)1;
}

void readBit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readBit_CALL_INSTANCE));
  CMOCK_readBit_CALL_INSTANCE* cmock_call_instance = (CMOCK_readBit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readBit_CallInstance = CMock_Guts_MemChain(Mock.readBit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void readBit_StubWithCallback(CMOCK_readBit_CALLBACK Callback)
{
  Mock.readBit_CallbackFunctionPointer = Callback;
}

void readBit_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readBit_CALL_INSTANCE));
  CMOCK_readBit_CALL_INSTANCE* cmock_call_instance = (CMOCK_readBit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readBit_CallInstance = CMock_Guts_MemChain(Mock.readBit_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

uint16 readBits(int bitsToRead)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_readBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_readBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.readBits_CallInstance);
  Mock.readBits_CallInstance = CMock_Guts_MemNext(Mock.readBits_CallInstance);
  if (Mock.readBits_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.readBits_FinalReturn;
    Mock.readBits_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.readBits_CallbackFunctionPointer != NULL)
  {
    return Mock.readBits_CallbackFunctionPointer(bitsToRead, Mock.readBits_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'readBits' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readBits' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readBits' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_bitsToRead, bitsToRead, cmock_line, "Function 'readBits' called with unexpected value for argument 'bitsToRead'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_readBits(CMOCK_readBits_CALL_INSTANCE* cmock_call_instance, int bitsToRead)
{
  cmock_call_instance->Expected_bitsToRead = bitsToRead;
}

void readBits_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readBits_CALL_INSTANCE));
  CMOCK_readBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_readBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readBits_CallInstance = CMock_Guts_MemChain(Mock.readBits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.readBits_IgnoreBool = (int)1;
}

void readBits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int bitsToRead, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readBits_CALL_INSTANCE));
  CMOCK_readBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_readBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readBits_CallInstance = CMock_Guts_MemChain(Mock.readBits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_readBits(cmock_call_instance, bitsToRead);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void readBits_StubWithCallback(CMOCK_readBits_CALLBACK Callback)
{
  Mock.readBits_CallbackFunctionPointer = Callback;
}

void readBits_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, int bitsToRead, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readBits_CALL_INSTANCE));
  CMOCK_readBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_readBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readBits_CallInstance = CMock_Guts_MemChain(Mock.readBits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_readBits(cmock_call_instance, bitsToRead);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

