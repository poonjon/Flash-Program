/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "mock_FlashProg.h"

typedef struct _CMOCK_readPGD_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint16 ReturnVal;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_readPGD_CALL_INSTANCE;

typedef struct _CMOCK_writePGD_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  int Expected_data;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_writePGD_CALL_INSTANCE;

typedef struct _CMOCK_PGC_high_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_PGC_high_CALL_INSTANCE;

typedef struct _CMOCK_PGC_low_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_PGC_low_CALL_INSTANCE;

typedef struct _CMOCK_MCLR_low_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_MCLR_low_CALL_INSTANCE;

typedef struct _CMOCK_MCLR_high_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_MCLR_high_CALL_INSTANCE;

typedef struct _CMOCK_PGM_low_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_PGM_low_CALL_INSTANCE;

typedef struct _CMOCK_PGM_high_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_PGM_high_CALL_INSTANCE;

typedef struct _CMOCK_PGD_high_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_PGD_high_CALL_INSTANCE;

typedef struct _CMOCK_PGD_low_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_PGD_low_CALL_INSTANCE;

typedef struct _CMOCK_enter_HVP_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_enter_HVP_CALL_INSTANCE;

typedef struct _CMOCK_exit_HVP_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_exit_HVP_CALL_INSTANCE;

typedef struct _CMOCK_bulkErase_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_bulkErase_CALL_INSTANCE;

typedef struct _CMOCK_readDeviceID1_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_readDeviceID1_CALL_INSTANCE;

typedef struct _CMOCK_readDeviceID2_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_readDeviceID2_CALL_INSTANCE;

typedef struct _CMOCK_enableWrite_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_enableWrite_CALL_INSTANCE;

typedef struct _CMOCK_flashSetAddress_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32 Expected_address;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_flashSetAddress_CALL_INSTANCE;

typedef struct _CMOCK_writeToBuffer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint16 Expected_data;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_writeToBuffer_CALL_INSTANCE;

typedef struct _CMOCK_flashWriteAndProgram_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint16 Expected_data;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_flashWriteAndProgram_CALL_INSTANCE;

typedef struct _CMOCK_flashWrite8Bits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint8 Expected_data;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_flashWrite8Bits_CALL_INSTANCE;

typedef struct _CMOCK_flashRead16Bits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint16 ReturnVal;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_flashRead16Bits_CALL_INSTANCE;

typedef struct _CMOCK_flashRead8Bits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8 ReturnVal;
  int CallOrder;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_flashRead8Bits_CALL_INSTANCE;

typedef struct _CMOCK_flashWriteHalfBlock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint16* Expected_data;
  uint16 Expected_size;
  uint32 Expected_halfBlockNumber;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_flashWriteHalfBlock_CALL_INSTANCE;

typedef struct _CMOCK_flashWriteBlock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint16* Expected_firstHalf;
  uint16* Expected_secondHalf;
  uint32 Expected_blockNumber;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_flashWriteBlock_CALL_INSTANCE;

typedef struct _CMOCK_flashReadBlock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint16* Expected_data;
  uint16 Expected_size;
  uint32 Expected_blockNumber;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_flashReadBlock_CALL_INSTANCE;

typedef struct _CMOCK_rowErase_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32 Expected_address;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_rowErase_CALL_INSTANCE;

static struct mock_FlashProgInstance
{
  int readPGD_IgnoreBool;
  uint16 readPGD_FinalReturn;
  CMOCK_readPGD_CALLBACK readPGD_CallbackFunctionPointer;
  int readPGD_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE readPGD_CallInstance;
  int writePGD_IgnoreBool;
  CMOCK_writePGD_CALLBACK writePGD_CallbackFunctionPointer;
  int writePGD_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE writePGD_CallInstance;
  int PGC_high_IgnoreBool;
  CMOCK_PGC_high_CALLBACK PGC_high_CallbackFunctionPointer;
  int PGC_high_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PGC_high_CallInstance;
  int PGC_low_IgnoreBool;
  CMOCK_PGC_low_CALLBACK PGC_low_CallbackFunctionPointer;
  int PGC_low_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PGC_low_CallInstance;
  int MCLR_low_IgnoreBool;
  CMOCK_MCLR_low_CALLBACK MCLR_low_CallbackFunctionPointer;
  int MCLR_low_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE MCLR_low_CallInstance;
  int MCLR_high_IgnoreBool;
  CMOCK_MCLR_high_CALLBACK MCLR_high_CallbackFunctionPointer;
  int MCLR_high_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE MCLR_high_CallInstance;
  int PGM_low_IgnoreBool;
  CMOCK_PGM_low_CALLBACK PGM_low_CallbackFunctionPointer;
  int PGM_low_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PGM_low_CallInstance;
  int PGM_high_IgnoreBool;
  CMOCK_PGM_high_CALLBACK PGM_high_CallbackFunctionPointer;
  int PGM_high_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PGM_high_CallInstance;
  int PGD_high_IgnoreBool;
  CMOCK_PGD_high_CALLBACK PGD_high_CallbackFunctionPointer;
  int PGD_high_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PGD_high_CallInstance;
  int PGD_low_IgnoreBool;
  CMOCK_PGD_low_CALLBACK PGD_low_CallbackFunctionPointer;
  int PGD_low_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PGD_low_CallInstance;
  int enter_HVP_IgnoreBool;
  CMOCK_enter_HVP_CALLBACK enter_HVP_CallbackFunctionPointer;
  int enter_HVP_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE enter_HVP_CallInstance;
  int exit_HVP_IgnoreBool;
  CMOCK_exit_HVP_CALLBACK exit_HVP_CallbackFunctionPointer;
  int exit_HVP_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE exit_HVP_CallInstance;
  int bulkErase_IgnoreBool;
  CMOCK_bulkErase_CALLBACK bulkErase_CallbackFunctionPointer;
  int bulkErase_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE bulkErase_CallInstance;
  int readDeviceID1_IgnoreBool;
  CMOCK_readDeviceID1_CALLBACK readDeviceID1_CallbackFunctionPointer;
  int readDeviceID1_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE readDeviceID1_CallInstance;
  int readDeviceID2_IgnoreBool;
  CMOCK_readDeviceID2_CALLBACK readDeviceID2_CallbackFunctionPointer;
  int readDeviceID2_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE readDeviceID2_CallInstance;
  int enableWrite_IgnoreBool;
  CMOCK_enableWrite_CALLBACK enableWrite_CallbackFunctionPointer;
  int enableWrite_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE enableWrite_CallInstance;
  int flashSetAddress_IgnoreBool;
  CMOCK_flashSetAddress_CALLBACK flashSetAddress_CallbackFunctionPointer;
  int flashSetAddress_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE flashSetAddress_CallInstance;
  int writeToBuffer_IgnoreBool;
  CMOCK_writeToBuffer_CALLBACK writeToBuffer_CallbackFunctionPointer;
  int writeToBuffer_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE writeToBuffer_CallInstance;
  int flashWriteAndProgram_IgnoreBool;
  CMOCK_flashWriteAndProgram_CALLBACK flashWriteAndProgram_CallbackFunctionPointer;
  int flashWriteAndProgram_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE flashWriteAndProgram_CallInstance;
  int flashWrite8Bits_IgnoreBool;
  CMOCK_flashWrite8Bits_CALLBACK flashWrite8Bits_CallbackFunctionPointer;
  int flashWrite8Bits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE flashWrite8Bits_CallInstance;
  int flashRead16Bits_IgnoreBool;
  uint16 flashRead16Bits_FinalReturn;
  CMOCK_flashRead16Bits_CALLBACK flashRead16Bits_CallbackFunctionPointer;
  int flashRead16Bits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE flashRead16Bits_CallInstance;
  int flashRead8Bits_IgnoreBool;
  uint8 flashRead8Bits_FinalReturn;
  CMOCK_flashRead8Bits_CALLBACK flashRead8Bits_CallbackFunctionPointer;
  int flashRead8Bits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE flashRead8Bits_CallInstance;
  int flashWriteHalfBlock_IgnoreBool;
  CMOCK_flashWriteHalfBlock_CALLBACK flashWriteHalfBlock_CallbackFunctionPointer;
  int flashWriteHalfBlock_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE flashWriteHalfBlock_CallInstance;
  int flashWriteBlock_IgnoreBool;
  CMOCK_flashWriteBlock_CALLBACK flashWriteBlock_CallbackFunctionPointer;
  int flashWriteBlock_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE flashWriteBlock_CallInstance;
  int flashReadBlock_IgnoreBool;
  CMOCK_flashReadBlock_CALLBACK flashReadBlock_CallbackFunctionPointer;
  int flashReadBlock_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE flashReadBlock_CallInstance;
  int rowErase_IgnoreBool;
  CMOCK_rowErase_CALLBACK rowErase_CallbackFunctionPointer;
  int rowErase_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE rowErase_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_FlashProg_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.readPGD_IgnoreBool)
    Mock.readPGD_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.readPGD_CallInstance, cmock_line, "Function 'readPGD' called less times than expected.");
  if (Mock.readPGD_CallbackFunctionPointer != NULL)
    Mock.readPGD_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.writePGD_IgnoreBool)
    Mock.writePGD_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.writePGD_CallInstance, cmock_line, "Function 'writePGD' called less times than expected.");
  if (Mock.writePGD_CallbackFunctionPointer != NULL)
    Mock.writePGD_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.PGC_high_IgnoreBool)
    Mock.PGC_high_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PGC_high_CallInstance, cmock_line, "Function 'PGC_high' called less times than expected.");
  if (Mock.PGC_high_CallbackFunctionPointer != NULL)
    Mock.PGC_high_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.PGC_low_IgnoreBool)
    Mock.PGC_low_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PGC_low_CallInstance, cmock_line, "Function 'PGC_low' called less times than expected.");
  if (Mock.PGC_low_CallbackFunctionPointer != NULL)
    Mock.PGC_low_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.MCLR_low_IgnoreBool)
    Mock.MCLR_low_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.MCLR_low_CallInstance, cmock_line, "Function 'MCLR_low' called less times than expected.");
  if (Mock.MCLR_low_CallbackFunctionPointer != NULL)
    Mock.MCLR_low_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.MCLR_high_IgnoreBool)
    Mock.MCLR_high_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.MCLR_high_CallInstance, cmock_line, "Function 'MCLR_high' called less times than expected.");
  if (Mock.MCLR_high_CallbackFunctionPointer != NULL)
    Mock.MCLR_high_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.PGM_low_IgnoreBool)
    Mock.PGM_low_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PGM_low_CallInstance, cmock_line, "Function 'PGM_low' called less times than expected.");
  if (Mock.PGM_low_CallbackFunctionPointer != NULL)
    Mock.PGM_low_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.PGM_high_IgnoreBool)
    Mock.PGM_high_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PGM_high_CallInstance, cmock_line, "Function 'PGM_high' called less times than expected.");
  if (Mock.PGM_high_CallbackFunctionPointer != NULL)
    Mock.PGM_high_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.PGD_high_IgnoreBool)
    Mock.PGD_high_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PGD_high_CallInstance, cmock_line, "Function 'PGD_high' called less times than expected.");
  if (Mock.PGD_high_CallbackFunctionPointer != NULL)
    Mock.PGD_high_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.PGD_low_IgnoreBool)
    Mock.PGD_low_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PGD_low_CallInstance, cmock_line, "Function 'PGD_low' called less times than expected.");
  if (Mock.PGD_low_CallbackFunctionPointer != NULL)
    Mock.PGD_low_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.enter_HVP_IgnoreBool)
    Mock.enter_HVP_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.enter_HVP_CallInstance, cmock_line, "Function 'enter_HVP' called less times than expected.");
  if (Mock.enter_HVP_CallbackFunctionPointer != NULL)
    Mock.enter_HVP_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.exit_HVP_IgnoreBool)
    Mock.exit_HVP_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.exit_HVP_CallInstance, cmock_line, "Function 'exit_HVP' called less times than expected.");
  if (Mock.exit_HVP_CallbackFunctionPointer != NULL)
    Mock.exit_HVP_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.bulkErase_IgnoreBool)
    Mock.bulkErase_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.bulkErase_CallInstance, cmock_line, "Function 'bulkErase' called less times than expected.");
  if (Mock.bulkErase_CallbackFunctionPointer != NULL)
    Mock.bulkErase_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.readDeviceID1_IgnoreBool)
    Mock.readDeviceID1_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.readDeviceID1_CallInstance, cmock_line, "Function 'readDeviceID1' called less times than expected.");
  if (Mock.readDeviceID1_CallbackFunctionPointer != NULL)
    Mock.readDeviceID1_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.readDeviceID2_IgnoreBool)
    Mock.readDeviceID2_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.readDeviceID2_CallInstance, cmock_line, "Function 'readDeviceID2' called less times than expected.");
  if (Mock.readDeviceID2_CallbackFunctionPointer != NULL)
    Mock.readDeviceID2_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.enableWrite_IgnoreBool)
    Mock.enableWrite_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.enableWrite_CallInstance, cmock_line, "Function 'enableWrite' called less times than expected.");
  if (Mock.enableWrite_CallbackFunctionPointer != NULL)
    Mock.enableWrite_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.flashSetAddress_IgnoreBool)
    Mock.flashSetAddress_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.flashSetAddress_CallInstance, cmock_line, "Function 'flashSetAddress' called less times than expected.");
  if (Mock.flashSetAddress_CallbackFunctionPointer != NULL)
    Mock.flashSetAddress_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.writeToBuffer_IgnoreBool)
    Mock.writeToBuffer_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.writeToBuffer_CallInstance, cmock_line, "Function 'writeToBuffer' called less times than expected.");
  if (Mock.writeToBuffer_CallbackFunctionPointer != NULL)
    Mock.writeToBuffer_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.flashWriteAndProgram_IgnoreBool)
    Mock.flashWriteAndProgram_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.flashWriteAndProgram_CallInstance, cmock_line, "Function 'flashWriteAndProgram' called less times than expected.");
  if (Mock.flashWriteAndProgram_CallbackFunctionPointer != NULL)
    Mock.flashWriteAndProgram_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.flashWrite8Bits_IgnoreBool)
    Mock.flashWrite8Bits_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.flashWrite8Bits_CallInstance, cmock_line, "Function 'flashWrite8Bits' called less times than expected.");
  if (Mock.flashWrite8Bits_CallbackFunctionPointer != NULL)
    Mock.flashWrite8Bits_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.flashRead16Bits_IgnoreBool)
    Mock.flashRead16Bits_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.flashRead16Bits_CallInstance, cmock_line, "Function 'flashRead16Bits' called less times than expected.");
  if (Mock.flashRead16Bits_CallbackFunctionPointer != NULL)
    Mock.flashRead16Bits_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.flashRead8Bits_IgnoreBool)
    Mock.flashRead8Bits_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.flashRead8Bits_CallInstance, cmock_line, "Function 'flashRead8Bits' called less times than expected.");
  if (Mock.flashRead8Bits_CallbackFunctionPointer != NULL)
    Mock.flashRead8Bits_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.flashWriteHalfBlock_IgnoreBool)
    Mock.flashWriteHalfBlock_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.flashWriteHalfBlock_CallInstance, cmock_line, "Function 'flashWriteHalfBlock' called less times than expected.");
  if (Mock.flashWriteHalfBlock_CallbackFunctionPointer != NULL)
    Mock.flashWriteHalfBlock_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.flashWriteBlock_IgnoreBool)
    Mock.flashWriteBlock_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.flashWriteBlock_CallInstance, cmock_line, "Function 'flashWriteBlock' called less times than expected.");
  if (Mock.flashWriteBlock_CallbackFunctionPointer != NULL)
    Mock.flashWriteBlock_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.flashReadBlock_IgnoreBool)
    Mock.flashReadBlock_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.flashReadBlock_CallInstance, cmock_line, "Function 'flashReadBlock' called less times than expected.");
  if (Mock.flashReadBlock_CallbackFunctionPointer != NULL)
    Mock.flashReadBlock_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.rowErase_IgnoreBool)
    Mock.rowErase_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.rowErase_CallInstance, cmock_line, "Function 'rowErase' called less times than expected.");
  if (Mock.rowErase_CallbackFunctionPointer != NULL)
    Mock.rowErase_CallInstance = CMOCK_GUTS_NONE;
}

void mock_FlashProg_Init(void)
{
  mock_FlashProg_Destroy();
}

void mock_FlashProg_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.readPGD_CallbackFunctionPointer = NULL;
  Mock.readPGD_CallbackCalls = 0;
  Mock.writePGD_CallbackFunctionPointer = NULL;
  Mock.writePGD_CallbackCalls = 0;
  Mock.PGC_high_CallbackFunctionPointer = NULL;
  Mock.PGC_high_CallbackCalls = 0;
  Mock.PGC_low_CallbackFunctionPointer = NULL;
  Mock.PGC_low_CallbackCalls = 0;
  Mock.MCLR_low_CallbackFunctionPointer = NULL;
  Mock.MCLR_low_CallbackCalls = 0;
  Mock.MCLR_high_CallbackFunctionPointer = NULL;
  Mock.MCLR_high_CallbackCalls = 0;
  Mock.PGM_low_CallbackFunctionPointer = NULL;
  Mock.PGM_low_CallbackCalls = 0;
  Mock.PGM_high_CallbackFunctionPointer = NULL;
  Mock.PGM_high_CallbackCalls = 0;
  Mock.PGD_high_CallbackFunctionPointer = NULL;
  Mock.PGD_high_CallbackCalls = 0;
  Mock.PGD_low_CallbackFunctionPointer = NULL;
  Mock.PGD_low_CallbackCalls = 0;
  Mock.enter_HVP_CallbackFunctionPointer = NULL;
  Mock.enter_HVP_CallbackCalls = 0;
  Mock.exit_HVP_CallbackFunctionPointer = NULL;
  Mock.exit_HVP_CallbackCalls = 0;
  Mock.bulkErase_CallbackFunctionPointer = NULL;
  Mock.bulkErase_CallbackCalls = 0;
  Mock.readDeviceID1_CallbackFunctionPointer = NULL;
  Mock.readDeviceID1_CallbackCalls = 0;
  Mock.readDeviceID2_CallbackFunctionPointer = NULL;
  Mock.readDeviceID2_CallbackCalls = 0;
  Mock.enableWrite_CallbackFunctionPointer = NULL;
  Mock.enableWrite_CallbackCalls = 0;
  Mock.flashSetAddress_CallbackFunctionPointer = NULL;
  Mock.flashSetAddress_CallbackCalls = 0;
  Mock.writeToBuffer_CallbackFunctionPointer = NULL;
  Mock.writeToBuffer_CallbackCalls = 0;
  Mock.flashWriteAndProgram_CallbackFunctionPointer = NULL;
  Mock.flashWriteAndProgram_CallbackCalls = 0;
  Mock.flashWrite8Bits_CallbackFunctionPointer = NULL;
  Mock.flashWrite8Bits_CallbackCalls = 0;
  Mock.flashRead16Bits_CallbackFunctionPointer = NULL;
  Mock.flashRead16Bits_CallbackCalls = 0;
  Mock.flashRead8Bits_CallbackFunctionPointer = NULL;
  Mock.flashRead8Bits_CallbackCalls = 0;
  Mock.flashWriteHalfBlock_CallbackFunctionPointer = NULL;
  Mock.flashWriteHalfBlock_CallbackCalls = 0;
  Mock.flashWriteBlock_CallbackFunctionPointer = NULL;
  Mock.flashWriteBlock_CallbackCalls = 0;
  Mock.flashReadBlock_CallbackFunctionPointer = NULL;
  Mock.flashReadBlock_CallbackCalls = 0;
  Mock.rowErase_CallbackFunctionPointer = NULL;
  Mock.rowErase_CallbackCalls = 0;
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

uint16 readPGD(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_readPGD_CALL_INSTANCE* cmock_call_instance = (CMOCK_readPGD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.readPGD_CallInstance);
  Mock.readPGD_CallInstance = CMock_Guts_MemNext(Mock.readPGD_CallInstance);
  if (Mock.readPGD_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.readPGD_FinalReturn;
    Mock.readPGD_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.readPGD_CallbackFunctionPointer != NULL)
  {
    return Mock.readPGD_CallbackFunctionPointer(Mock.readPGD_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'readPGD' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readPGD' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readPGD' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  return cmock_call_instance->ReturnVal;
}

void readPGD_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readPGD_CALL_INSTANCE));
  CMOCK_readPGD_CALL_INSTANCE* cmock_call_instance = (CMOCK_readPGD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readPGD_CallInstance = CMock_Guts_MemChain(Mock.readPGD_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.readPGD_IgnoreBool = (int)1;
}

void readPGD_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readPGD_CALL_INSTANCE));
  CMOCK_readPGD_CALL_INSTANCE* cmock_call_instance = (CMOCK_readPGD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readPGD_CallInstance = CMock_Guts_MemChain(Mock.readPGD_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void readPGD_StubWithCallback(CMOCK_readPGD_CALLBACK Callback)
{
  Mock.readPGD_CallbackFunctionPointer = Callback;
}

void readPGD_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readPGD_CALL_INSTANCE));
  CMOCK_readPGD_CALL_INSTANCE* cmock_call_instance = (CMOCK_readPGD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readPGD_CallInstance = CMock_Guts_MemChain(Mock.readPGD_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void writePGD(int data)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_writePGD_CALL_INSTANCE* cmock_call_instance = (CMOCK_writePGD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.writePGD_CallInstance);
  Mock.writePGD_CallInstance = CMock_Guts_MemNext(Mock.writePGD_CallInstance);
  if (Mock.writePGD_IgnoreBool)
  {
    return;
  }
  if (Mock.writePGD_CallbackFunctionPointer != NULL)
  {
    Mock.writePGD_CallbackFunctionPointer(data, Mock.writePGD_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'writePGD' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writePGD' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writePGD' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_data, data, cmock_line, "Function 'writePGD' called with unexpected value for argument 'data'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_writePGD(CMOCK_writePGD_CALL_INSTANCE* cmock_call_instance, int data)
{
  cmock_call_instance->Expected_data = data;
}

void writePGD_CMockIgnore(void)
{
  Mock.writePGD_IgnoreBool = (int)1;
}

void writePGD_CMockExpect(UNITY_LINE_TYPE cmock_line, int data)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writePGD_CALL_INSTANCE));
  CMOCK_writePGD_CALL_INSTANCE* cmock_call_instance = (CMOCK_writePGD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writePGD_CallInstance = CMock_Guts_MemChain(Mock.writePGD_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writePGD(cmock_call_instance, data);
}

void writePGD_StubWithCallback(CMOCK_writePGD_CALLBACK Callback)
{
  Mock.writePGD_CallbackFunctionPointer = Callback;
}

void writePGD_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, int data, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writePGD_CALL_INSTANCE));
  CMOCK_writePGD_CALL_INSTANCE* cmock_call_instance = (CMOCK_writePGD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writePGD_CallInstance = CMock_Guts_MemChain(Mock.writePGD_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writePGD(cmock_call_instance, data);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void PGC_high(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PGC_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGC_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PGC_high_CallInstance);
  Mock.PGC_high_CallInstance = CMock_Guts_MemNext(Mock.PGC_high_CallInstance);
  if (Mock.PGC_high_IgnoreBool)
  {
    return;
  }
  if (Mock.PGC_high_CallbackFunctionPointer != NULL)
  {
    Mock.PGC_high_CallbackFunctionPointer(Mock.PGC_high_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PGC_high' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGC_high' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGC_high' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void PGC_high_CMockIgnore(void)
{
  Mock.PGC_high_IgnoreBool = (int)1;
}

void PGC_high_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGC_high_CALL_INSTANCE));
  CMOCK_PGC_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGC_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGC_high_CallInstance = CMock_Guts_MemChain(Mock.PGC_high_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void PGC_high_StubWithCallback(CMOCK_PGC_high_CALLBACK Callback)
{
  Mock.PGC_high_CallbackFunctionPointer = Callback;
}

void PGC_high_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGC_high_CALL_INSTANCE));
  CMOCK_PGC_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGC_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGC_high_CallInstance = CMock_Guts_MemChain(Mock.PGC_high_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void PGC_low(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PGC_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGC_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PGC_low_CallInstance);
  Mock.PGC_low_CallInstance = CMock_Guts_MemNext(Mock.PGC_low_CallInstance);
  if (Mock.PGC_low_IgnoreBool)
  {
    return;
  }
  if (Mock.PGC_low_CallbackFunctionPointer != NULL)
  {
    Mock.PGC_low_CallbackFunctionPointer(Mock.PGC_low_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PGC_low' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGC_low' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGC_low' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void PGC_low_CMockIgnore(void)
{
  Mock.PGC_low_IgnoreBool = (int)1;
}

void PGC_low_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGC_low_CALL_INSTANCE));
  CMOCK_PGC_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGC_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGC_low_CallInstance = CMock_Guts_MemChain(Mock.PGC_low_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void PGC_low_StubWithCallback(CMOCK_PGC_low_CALLBACK Callback)
{
  Mock.PGC_low_CallbackFunctionPointer = Callback;
}

void PGC_low_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGC_low_CALL_INSTANCE));
  CMOCK_PGC_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGC_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGC_low_CallInstance = CMock_Guts_MemChain(Mock.PGC_low_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void MCLR_low(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MCLR_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_MCLR_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.MCLR_low_CallInstance);
  Mock.MCLR_low_CallInstance = CMock_Guts_MemNext(Mock.MCLR_low_CallInstance);
  if (Mock.MCLR_low_IgnoreBool)
  {
    return;
  }
  if (Mock.MCLR_low_CallbackFunctionPointer != NULL)
  {
    Mock.MCLR_low_CallbackFunctionPointer(Mock.MCLR_low_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'MCLR_low' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'MCLR_low' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'MCLR_low' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void MCLR_low_CMockIgnore(void)
{
  Mock.MCLR_low_IgnoreBool = (int)1;
}

void MCLR_low_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_MCLR_low_CALL_INSTANCE));
  CMOCK_MCLR_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_MCLR_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.MCLR_low_CallInstance = CMock_Guts_MemChain(Mock.MCLR_low_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void MCLR_low_StubWithCallback(CMOCK_MCLR_low_CALLBACK Callback)
{
  Mock.MCLR_low_CallbackFunctionPointer = Callback;
}

void MCLR_low_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_MCLR_low_CALL_INSTANCE));
  CMOCK_MCLR_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_MCLR_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.MCLR_low_CallInstance = CMock_Guts_MemChain(Mock.MCLR_low_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void MCLR_high(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MCLR_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_MCLR_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.MCLR_high_CallInstance);
  Mock.MCLR_high_CallInstance = CMock_Guts_MemNext(Mock.MCLR_high_CallInstance);
  if (Mock.MCLR_high_IgnoreBool)
  {
    return;
  }
  if (Mock.MCLR_high_CallbackFunctionPointer != NULL)
  {
    Mock.MCLR_high_CallbackFunctionPointer(Mock.MCLR_high_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'MCLR_high' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'MCLR_high' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'MCLR_high' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void MCLR_high_CMockIgnore(void)
{
  Mock.MCLR_high_IgnoreBool = (int)1;
}

void MCLR_high_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_MCLR_high_CALL_INSTANCE));
  CMOCK_MCLR_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_MCLR_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.MCLR_high_CallInstance = CMock_Guts_MemChain(Mock.MCLR_high_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void MCLR_high_StubWithCallback(CMOCK_MCLR_high_CALLBACK Callback)
{
  Mock.MCLR_high_CallbackFunctionPointer = Callback;
}

void MCLR_high_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_MCLR_high_CALL_INSTANCE));
  CMOCK_MCLR_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_MCLR_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.MCLR_high_CallInstance = CMock_Guts_MemChain(Mock.MCLR_high_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void PGM_low(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PGM_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGM_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PGM_low_CallInstance);
  Mock.PGM_low_CallInstance = CMock_Guts_MemNext(Mock.PGM_low_CallInstance);
  if (Mock.PGM_low_IgnoreBool)
  {
    return;
  }
  if (Mock.PGM_low_CallbackFunctionPointer != NULL)
  {
    Mock.PGM_low_CallbackFunctionPointer(Mock.PGM_low_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PGM_low' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGM_low' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGM_low' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void PGM_low_CMockIgnore(void)
{
  Mock.PGM_low_IgnoreBool = (int)1;
}

void PGM_low_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGM_low_CALL_INSTANCE));
  CMOCK_PGM_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGM_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGM_low_CallInstance = CMock_Guts_MemChain(Mock.PGM_low_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void PGM_low_StubWithCallback(CMOCK_PGM_low_CALLBACK Callback)
{
  Mock.PGM_low_CallbackFunctionPointer = Callback;
}

void PGM_low_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGM_low_CALL_INSTANCE));
  CMOCK_PGM_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGM_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGM_low_CallInstance = CMock_Guts_MemChain(Mock.PGM_low_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void PGM_high(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PGM_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGM_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PGM_high_CallInstance);
  Mock.PGM_high_CallInstance = CMock_Guts_MemNext(Mock.PGM_high_CallInstance);
  if (Mock.PGM_high_IgnoreBool)
  {
    return;
  }
  if (Mock.PGM_high_CallbackFunctionPointer != NULL)
  {
    Mock.PGM_high_CallbackFunctionPointer(Mock.PGM_high_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PGM_high' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGM_high' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGM_high' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void PGM_high_CMockIgnore(void)
{
  Mock.PGM_high_IgnoreBool = (int)1;
}

void PGM_high_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGM_high_CALL_INSTANCE));
  CMOCK_PGM_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGM_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGM_high_CallInstance = CMock_Guts_MemChain(Mock.PGM_high_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void PGM_high_StubWithCallback(CMOCK_PGM_high_CALLBACK Callback)
{
  Mock.PGM_high_CallbackFunctionPointer = Callback;
}

void PGM_high_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGM_high_CALL_INSTANCE));
  CMOCK_PGM_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGM_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGM_high_CallInstance = CMock_Guts_MemChain(Mock.PGM_high_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void PGD_high(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PGD_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGD_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PGD_high_CallInstance);
  Mock.PGD_high_CallInstance = CMock_Guts_MemNext(Mock.PGD_high_CallInstance);
  if (Mock.PGD_high_IgnoreBool)
  {
    return;
  }
  if (Mock.PGD_high_CallbackFunctionPointer != NULL)
  {
    Mock.PGD_high_CallbackFunctionPointer(Mock.PGD_high_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PGD_high' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGD_high' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGD_high' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void PGD_high_CMockIgnore(void)
{
  Mock.PGD_high_IgnoreBool = (int)1;
}

void PGD_high_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGD_high_CALL_INSTANCE));
  CMOCK_PGD_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGD_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGD_high_CallInstance = CMock_Guts_MemChain(Mock.PGD_high_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void PGD_high_StubWithCallback(CMOCK_PGD_high_CALLBACK Callback)
{
  Mock.PGD_high_CallbackFunctionPointer = Callback;
}

void PGD_high_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGD_high_CALL_INSTANCE));
  CMOCK_PGD_high_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGD_high_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGD_high_CallInstance = CMock_Guts_MemChain(Mock.PGD_high_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void PGD_low(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PGD_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGD_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PGD_low_CallInstance);
  Mock.PGD_low_CallInstance = CMock_Guts_MemNext(Mock.PGD_low_CallInstance);
  if (Mock.PGD_low_IgnoreBool)
  {
    return;
  }
  if (Mock.PGD_low_CallbackFunctionPointer != NULL)
  {
    Mock.PGD_low_CallbackFunctionPointer(Mock.PGD_low_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PGD_low' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGD_low' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'PGD_low' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void PGD_low_CMockIgnore(void)
{
  Mock.PGD_low_IgnoreBool = (int)1;
}

void PGD_low_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGD_low_CALL_INSTANCE));
  CMOCK_PGD_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGD_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGD_low_CallInstance = CMock_Guts_MemChain(Mock.PGD_low_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void PGD_low_StubWithCallback(CMOCK_PGD_low_CALLBACK Callback)
{
  Mock.PGD_low_CallbackFunctionPointer = Callback;
}

void PGD_low_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PGD_low_CALL_INSTANCE));
  CMOCK_PGD_low_CALL_INSTANCE* cmock_call_instance = (CMOCK_PGD_low_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PGD_low_CallInstance = CMock_Guts_MemChain(Mock.PGD_low_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void enter_HVP(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_enter_HVP_CALL_INSTANCE* cmock_call_instance = (CMOCK_enter_HVP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.enter_HVP_CallInstance);
  Mock.enter_HVP_CallInstance = CMock_Guts_MemNext(Mock.enter_HVP_CallInstance);
  if (Mock.enter_HVP_IgnoreBool)
  {
    return;
  }
  if (Mock.enter_HVP_CallbackFunctionPointer != NULL)
  {
    Mock.enter_HVP_CallbackFunctionPointer(Mock.enter_HVP_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'enter_HVP' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'enter_HVP' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'enter_HVP' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void enter_HVP_CMockIgnore(void)
{
  Mock.enter_HVP_IgnoreBool = (int)1;
}

void enter_HVP_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_enter_HVP_CALL_INSTANCE));
  CMOCK_enter_HVP_CALL_INSTANCE* cmock_call_instance = (CMOCK_enter_HVP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.enter_HVP_CallInstance = CMock_Guts_MemChain(Mock.enter_HVP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void enter_HVP_StubWithCallback(CMOCK_enter_HVP_CALLBACK Callback)
{
  Mock.enter_HVP_CallbackFunctionPointer = Callback;
}

void enter_HVP_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_enter_HVP_CALL_INSTANCE));
  CMOCK_enter_HVP_CALL_INSTANCE* cmock_call_instance = (CMOCK_enter_HVP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.enter_HVP_CallInstance = CMock_Guts_MemChain(Mock.enter_HVP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void exit_HVP(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_exit_HVP_CALL_INSTANCE* cmock_call_instance = (CMOCK_exit_HVP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.exit_HVP_CallInstance);
  Mock.exit_HVP_CallInstance = CMock_Guts_MemNext(Mock.exit_HVP_CallInstance);
  if (Mock.exit_HVP_IgnoreBool)
  {
    return;
  }
  if (Mock.exit_HVP_CallbackFunctionPointer != NULL)
  {
    Mock.exit_HVP_CallbackFunctionPointer(Mock.exit_HVP_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'exit_HVP' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'exit_HVP' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'exit_HVP' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void exit_HVP_CMockIgnore(void)
{
  Mock.exit_HVP_IgnoreBool = (int)1;
}

void exit_HVP_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_exit_HVP_CALL_INSTANCE));
  CMOCK_exit_HVP_CALL_INSTANCE* cmock_call_instance = (CMOCK_exit_HVP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.exit_HVP_CallInstance = CMock_Guts_MemChain(Mock.exit_HVP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void exit_HVP_StubWithCallback(CMOCK_exit_HVP_CALLBACK Callback)
{
  Mock.exit_HVP_CallbackFunctionPointer = Callback;
}

void exit_HVP_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_exit_HVP_CALL_INSTANCE));
  CMOCK_exit_HVP_CALL_INSTANCE* cmock_call_instance = (CMOCK_exit_HVP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.exit_HVP_CallInstance = CMock_Guts_MemChain(Mock.exit_HVP_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void bulkErase(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_bulkErase_CALL_INSTANCE* cmock_call_instance = (CMOCK_bulkErase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.bulkErase_CallInstance);
  Mock.bulkErase_CallInstance = CMock_Guts_MemNext(Mock.bulkErase_CallInstance);
  if (Mock.bulkErase_IgnoreBool)
  {
    return;
  }
  if (Mock.bulkErase_CallbackFunctionPointer != NULL)
  {
    Mock.bulkErase_CallbackFunctionPointer(Mock.bulkErase_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'bulkErase' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'bulkErase' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'bulkErase' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void bulkErase_CMockIgnore(void)
{
  Mock.bulkErase_IgnoreBool = (int)1;
}

void bulkErase_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bulkErase_CALL_INSTANCE));
  CMOCK_bulkErase_CALL_INSTANCE* cmock_call_instance = (CMOCK_bulkErase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.bulkErase_CallInstance = CMock_Guts_MemChain(Mock.bulkErase_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void bulkErase_StubWithCallback(CMOCK_bulkErase_CALLBACK Callback)
{
  Mock.bulkErase_CallbackFunctionPointer = Callback;
}

void bulkErase_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_bulkErase_CALL_INSTANCE));
  CMOCK_bulkErase_CALL_INSTANCE* cmock_call_instance = (CMOCK_bulkErase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.bulkErase_CallInstance = CMock_Guts_MemChain(Mock.bulkErase_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void readDeviceID1(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_readDeviceID1_CALL_INSTANCE* cmock_call_instance = (CMOCK_readDeviceID1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.readDeviceID1_CallInstance);
  Mock.readDeviceID1_CallInstance = CMock_Guts_MemNext(Mock.readDeviceID1_CallInstance);
  if (Mock.readDeviceID1_IgnoreBool)
  {
    return;
  }
  if (Mock.readDeviceID1_CallbackFunctionPointer != NULL)
  {
    Mock.readDeviceID1_CallbackFunctionPointer(Mock.readDeviceID1_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'readDeviceID1' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readDeviceID1' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readDeviceID1' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void readDeviceID1_CMockIgnore(void)
{
  Mock.readDeviceID1_IgnoreBool = (int)1;
}

void readDeviceID1_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readDeviceID1_CALL_INSTANCE));
  CMOCK_readDeviceID1_CALL_INSTANCE* cmock_call_instance = (CMOCK_readDeviceID1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readDeviceID1_CallInstance = CMock_Guts_MemChain(Mock.readDeviceID1_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void readDeviceID1_StubWithCallback(CMOCK_readDeviceID1_CALLBACK Callback)
{
  Mock.readDeviceID1_CallbackFunctionPointer = Callback;
}

void readDeviceID1_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readDeviceID1_CALL_INSTANCE));
  CMOCK_readDeviceID1_CALL_INSTANCE* cmock_call_instance = (CMOCK_readDeviceID1_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readDeviceID1_CallInstance = CMock_Guts_MemChain(Mock.readDeviceID1_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void readDeviceID2(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_readDeviceID2_CALL_INSTANCE* cmock_call_instance = (CMOCK_readDeviceID2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.readDeviceID2_CallInstance);
  Mock.readDeviceID2_CallInstance = CMock_Guts_MemNext(Mock.readDeviceID2_CallInstance);
  if (Mock.readDeviceID2_IgnoreBool)
  {
    return;
  }
  if (Mock.readDeviceID2_CallbackFunctionPointer != NULL)
  {
    Mock.readDeviceID2_CallbackFunctionPointer(Mock.readDeviceID2_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'readDeviceID2' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readDeviceID2' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'readDeviceID2' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void readDeviceID2_CMockIgnore(void)
{
  Mock.readDeviceID2_IgnoreBool = (int)1;
}

void readDeviceID2_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readDeviceID2_CALL_INSTANCE));
  CMOCK_readDeviceID2_CALL_INSTANCE* cmock_call_instance = (CMOCK_readDeviceID2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readDeviceID2_CallInstance = CMock_Guts_MemChain(Mock.readDeviceID2_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void readDeviceID2_StubWithCallback(CMOCK_readDeviceID2_CALLBACK Callback)
{
  Mock.readDeviceID2_CallbackFunctionPointer = Callback;
}

void readDeviceID2_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_readDeviceID2_CALL_INSTANCE));
  CMOCK_readDeviceID2_CALL_INSTANCE* cmock_call_instance = (CMOCK_readDeviceID2_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.readDeviceID2_CallInstance = CMock_Guts_MemChain(Mock.readDeviceID2_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void enableWrite(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_enableWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_enableWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.enableWrite_CallInstance);
  Mock.enableWrite_CallInstance = CMock_Guts_MemNext(Mock.enableWrite_CallInstance);
  if (Mock.enableWrite_IgnoreBool)
  {
    return;
  }
  if (Mock.enableWrite_CallbackFunctionPointer != NULL)
  {
    Mock.enableWrite_CallbackFunctionPointer(Mock.enableWrite_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'enableWrite' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'enableWrite' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'enableWrite' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void enableWrite_CMockIgnore(void)
{
  Mock.enableWrite_IgnoreBool = (int)1;
}

void enableWrite_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_enableWrite_CALL_INSTANCE));
  CMOCK_enableWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_enableWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.enableWrite_CallInstance = CMock_Guts_MemChain(Mock.enableWrite_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
}

void enableWrite_StubWithCallback(CMOCK_enableWrite_CALLBACK Callback)
{
  Mock.enableWrite_CallbackFunctionPointer = Callback;
}

void enableWrite_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_enableWrite_CALL_INSTANCE));
  CMOCK_enableWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_enableWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.enableWrite_CallInstance = CMock_Guts_MemChain(Mock.enableWrite_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void flashSetAddress(uint32 address)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_flashSetAddress_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashSetAddress_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.flashSetAddress_CallInstance);
  Mock.flashSetAddress_CallInstance = CMock_Guts_MemNext(Mock.flashSetAddress_CallInstance);
  if (Mock.flashSetAddress_IgnoreBool)
  {
    return;
  }
  if (Mock.flashSetAddress_CallbackFunctionPointer != NULL)
  {
    Mock.flashSetAddress_CallbackFunctionPointer(address, Mock.flashSetAddress_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'flashSetAddress' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashSetAddress' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashSetAddress' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_address, address, cmock_line, "Function 'flashSetAddress' called with unexpected value for argument 'address'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_flashSetAddress(CMOCK_flashSetAddress_CALL_INSTANCE* cmock_call_instance, uint32 address)
{
  cmock_call_instance->Expected_address = address;
}

void flashSetAddress_CMockIgnore(void)
{
  Mock.flashSetAddress_IgnoreBool = (int)1;
}

void flashSetAddress_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 address)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashSetAddress_CALL_INSTANCE));
  CMOCK_flashSetAddress_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashSetAddress_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashSetAddress_CallInstance = CMock_Guts_MemChain(Mock.flashSetAddress_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashSetAddress(cmock_call_instance, address);
}

void flashSetAddress_StubWithCallback(CMOCK_flashSetAddress_CALLBACK Callback)
{
  Mock.flashSetAddress_CallbackFunctionPointer = Callback;
}

void flashSetAddress_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint32 address, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashSetAddress_CALL_INSTANCE));
  CMOCK_flashSetAddress_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashSetAddress_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashSetAddress_CallInstance = CMock_Guts_MemChain(Mock.flashSetAddress_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashSetAddress(cmock_call_instance, address);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void writeToBuffer(uint16 data)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_writeToBuffer_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeToBuffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.writeToBuffer_CallInstance);
  Mock.writeToBuffer_CallInstance = CMock_Guts_MemNext(Mock.writeToBuffer_CallInstance);
  if (Mock.writeToBuffer_IgnoreBool)
  {
    return;
  }
  if (Mock.writeToBuffer_CallbackFunctionPointer != NULL)
  {
    Mock.writeToBuffer_CallbackFunctionPointer(data, Mock.writeToBuffer_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'writeToBuffer' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writeToBuffer' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'writeToBuffer' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_data, data, cmock_line, "Function 'writeToBuffer' called with unexpected value for argument 'data'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_writeToBuffer(CMOCK_writeToBuffer_CALL_INSTANCE* cmock_call_instance, uint16 data)
{
  cmock_call_instance->Expected_data = data;
}

void writeToBuffer_CMockIgnore(void)
{
  Mock.writeToBuffer_IgnoreBool = (int)1;
}

void writeToBuffer_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16 data)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writeToBuffer_CALL_INSTANCE));
  CMOCK_writeToBuffer_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeToBuffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writeToBuffer_CallInstance = CMock_Guts_MemChain(Mock.writeToBuffer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writeToBuffer(cmock_call_instance, data);
}

void writeToBuffer_StubWithCallback(CMOCK_writeToBuffer_CALLBACK Callback)
{
  Mock.writeToBuffer_CallbackFunctionPointer = Callback;
}

void writeToBuffer_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint16 data, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_writeToBuffer_CALL_INSTANCE));
  CMOCK_writeToBuffer_CALL_INSTANCE* cmock_call_instance = (CMOCK_writeToBuffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.writeToBuffer_CallInstance = CMock_Guts_MemChain(Mock.writeToBuffer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_writeToBuffer(cmock_call_instance, data);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void flashWriteAndProgram(uint16 data)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_flashWriteAndProgram_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteAndProgram_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.flashWriteAndProgram_CallInstance);
  Mock.flashWriteAndProgram_CallInstance = CMock_Guts_MemNext(Mock.flashWriteAndProgram_CallInstance);
  if (Mock.flashWriteAndProgram_IgnoreBool)
  {
    return;
  }
  if (Mock.flashWriteAndProgram_CallbackFunctionPointer != NULL)
  {
    Mock.flashWriteAndProgram_CallbackFunctionPointer(data, Mock.flashWriteAndProgram_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'flashWriteAndProgram' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashWriteAndProgram' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashWriteAndProgram' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_data, data, cmock_line, "Function 'flashWriteAndProgram' called with unexpected value for argument 'data'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_flashWriteAndProgram(CMOCK_flashWriteAndProgram_CALL_INSTANCE* cmock_call_instance, uint16 data)
{
  cmock_call_instance->Expected_data = data;
}

void flashWriteAndProgram_CMockIgnore(void)
{
  Mock.flashWriteAndProgram_IgnoreBool = (int)1;
}

void flashWriteAndProgram_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16 data)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashWriteAndProgram_CALL_INSTANCE));
  CMOCK_flashWriteAndProgram_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteAndProgram_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashWriteAndProgram_CallInstance = CMock_Guts_MemChain(Mock.flashWriteAndProgram_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashWriteAndProgram(cmock_call_instance, data);
}

void flashWriteAndProgram_StubWithCallback(CMOCK_flashWriteAndProgram_CALLBACK Callback)
{
  Mock.flashWriteAndProgram_CallbackFunctionPointer = Callback;
}

void flashWriteAndProgram_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint16 data, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashWriteAndProgram_CALL_INSTANCE));
  CMOCK_flashWriteAndProgram_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteAndProgram_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashWriteAndProgram_CallInstance = CMock_Guts_MemChain(Mock.flashWriteAndProgram_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashWriteAndProgram(cmock_call_instance, data);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void flashWrite8Bits(uint8 data)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_flashWrite8Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWrite8Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.flashWrite8Bits_CallInstance);
  Mock.flashWrite8Bits_CallInstance = CMock_Guts_MemNext(Mock.flashWrite8Bits_CallInstance);
  if (Mock.flashWrite8Bits_IgnoreBool)
  {
    return;
  }
  if (Mock.flashWrite8Bits_CallbackFunctionPointer != NULL)
  {
    Mock.flashWrite8Bits_CallbackFunctionPointer(data, Mock.flashWrite8Bits_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'flashWrite8Bits' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashWrite8Bits' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashWrite8Bits' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_data, data, cmock_line, "Function 'flashWrite8Bits' called with unexpected value for argument 'data'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_flashWrite8Bits(CMOCK_flashWrite8Bits_CALL_INSTANCE* cmock_call_instance, uint8 data)
{
  cmock_call_instance->Expected_data = data;
}

void flashWrite8Bits_CMockIgnore(void)
{
  Mock.flashWrite8Bits_IgnoreBool = (int)1;
}

void flashWrite8Bits_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8 data)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashWrite8Bits_CALL_INSTANCE));
  CMOCK_flashWrite8Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWrite8Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashWrite8Bits_CallInstance = CMock_Guts_MemChain(Mock.flashWrite8Bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashWrite8Bits(cmock_call_instance, data);
}

void flashWrite8Bits_StubWithCallback(CMOCK_flashWrite8Bits_CALLBACK Callback)
{
  Mock.flashWrite8Bits_CallbackFunctionPointer = Callback;
}

void flashWrite8Bits_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint8 data, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashWrite8Bits_CALL_INSTANCE));
  CMOCK_flashWrite8Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWrite8Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashWrite8Bits_CallInstance = CMock_Guts_MemChain(Mock.flashWrite8Bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashWrite8Bits(cmock_call_instance, data);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

uint16 flashRead16Bits(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_flashRead16Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashRead16Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.flashRead16Bits_CallInstance);
  Mock.flashRead16Bits_CallInstance = CMock_Guts_MemNext(Mock.flashRead16Bits_CallInstance);
  if (Mock.flashRead16Bits_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.flashRead16Bits_FinalReturn;
    Mock.flashRead16Bits_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.flashRead16Bits_CallbackFunctionPointer != NULL)
  {
    return Mock.flashRead16Bits_CallbackFunctionPointer(Mock.flashRead16Bits_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'flashRead16Bits' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashRead16Bits' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashRead16Bits' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  return cmock_call_instance->ReturnVal;
}

void flashRead16Bits_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashRead16Bits_CALL_INSTANCE));
  CMOCK_flashRead16Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashRead16Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashRead16Bits_CallInstance = CMock_Guts_MemChain(Mock.flashRead16Bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.flashRead16Bits_IgnoreBool = (int)1;
}

void flashRead16Bits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint16 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashRead16Bits_CALL_INSTANCE));
  CMOCK_flashRead16Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashRead16Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashRead16Bits_CallInstance = CMock_Guts_MemChain(Mock.flashRead16Bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void flashRead16Bits_StubWithCallback(CMOCK_flashRead16Bits_CALLBACK Callback)
{
  Mock.flashRead16Bits_CallbackFunctionPointer = Callback;
}

void flashRead16Bits_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashRead16Bits_CALL_INSTANCE));
  CMOCK_flashRead16Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashRead16Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashRead16Bits_CallInstance = CMock_Guts_MemChain(Mock.flashRead16Bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

uint8 flashRead8Bits(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_flashRead8Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashRead8Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.flashRead8Bits_CallInstance);
  Mock.flashRead8Bits_CallInstance = CMock_Guts_MemNext(Mock.flashRead8Bits_CallInstance);
  if (Mock.flashRead8Bits_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.flashRead8Bits_FinalReturn;
    Mock.flashRead8Bits_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (Mock.flashRead8Bits_CallbackFunctionPointer != NULL)
  {
    return Mock.flashRead8Bits_CallbackFunctionPointer(Mock.flashRead8Bits_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'flashRead8Bits' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashRead8Bits' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashRead8Bits' called later than expected.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  return cmock_call_instance->ReturnVal;
}

void flashRead8Bits_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashRead8Bits_CALL_INSTANCE));
  CMOCK_flashRead8Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashRead8Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashRead8Bits_CallInstance = CMock_Guts_MemChain(Mock.flashRead8Bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.flashRead8Bits_IgnoreBool = (int)1;
}

void flashRead8Bits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashRead8Bits_CALL_INSTANCE));
  CMOCK_flashRead8Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashRead8Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashRead8Bits_CallInstance = CMock_Guts_MemChain(Mock.flashRead8Bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void flashRead8Bits_StubWithCallback(CMOCK_flashRead8Bits_CALLBACK Callback)
{
  Mock.flashRead8Bits_CallbackFunctionPointer = Callback;
}

void flashRead8Bits_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashRead8Bits_CALL_INSTANCE));
  CMOCK_flashRead8Bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashRead8Bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashRead8Bits_CallInstance = CMock_Guts_MemChain(Mock.flashRead8Bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void flashWriteHalfBlock(uint16* data, uint16 size, uint32 halfBlockNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_flashWriteHalfBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteHalfBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.flashWriteHalfBlock_CallInstance);
  Mock.flashWriteHalfBlock_CallInstance = CMock_Guts_MemNext(Mock.flashWriteHalfBlock_CallInstance);
  if (Mock.flashWriteHalfBlock_IgnoreBool)
  {
    return;
  }
  if (Mock.flashWriteHalfBlock_CallbackFunctionPointer != NULL)
  {
    Mock.flashWriteHalfBlock_CallbackFunctionPointer(data, size, halfBlockNumber, Mock.flashWriteHalfBlock_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'flashWriteHalfBlock' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashWriteHalfBlock' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashWriteHalfBlock' called later than expected.");
  if (cmock_call_instance->Expected_data == NULL)
    { UNITY_TEST_ASSERT_NULL(data, cmock_line, "Expected NULL. Function 'flashWriteHalfBlock' called with unexpected value for argument 'data'."); }
  else
    { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, "Function 'flashWriteHalfBlock' called with unexpected value for argument 'data'."); }
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_size, size, cmock_line, "Function 'flashWriteHalfBlock' called with unexpected value for argument 'size'.");
  UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_halfBlockNumber, halfBlockNumber, cmock_line, "Function 'flashWriteHalfBlock' called with unexpected value for argument 'halfBlockNumber'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_flashWriteHalfBlock(CMOCK_flashWriteHalfBlock_CALL_INSTANCE* cmock_call_instance, uint16* data, uint16 size, uint32 halfBlockNumber)
{
  cmock_call_instance->Expected_data = data;
  cmock_call_instance->Expected_size = size;
  cmock_call_instance->Expected_halfBlockNumber = halfBlockNumber;
}

void flashWriteHalfBlock_CMockIgnore(void)
{
  Mock.flashWriteHalfBlock_IgnoreBool = (int)1;
}

void flashWriteHalfBlock_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16* data, uint16 size, uint32 halfBlockNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashWriteHalfBlock_CALL_INSTANCE));
  CMOCK_flashWriteHalfBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteHalfBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashWriteHalfBlock_CallInstance = CMock_Guts_MemChain(Mock.flashWriteHalfBlock_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashWriteHalfBlock(cmock_call_instance, data, size, halfBlockNumber);
}

void flashWriteHalfBlock_StubWithCallback(CMOCK_flashWriteHalfBlock_CALLBACK Callback)
{
  Mock.flashWriteHalfBlock_CallbackFunctionPointer = Callback;
}

void flashWriteHalfBlock_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint16* data, uint16 size, uint32 halfBlockNumber, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashWriteHalfBlock_CALL_INSTANCE));
  CMOCK_flashWriteHalfBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteHalfBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashWriteHalfBlock_CallInstance = CMock_Guts_MemChain(Mock.flashWriteHalfBlock_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashWriteHalfBlock(cmock_call_instance, data, size, halfBlockNumber);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void flashWriteBlock(uint16* firstHalf, uint16* secondHalf, uint32 blockNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_flashWriteBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.flashWriteBlock_CallInstance);
  Mock.flashWriteBlock_CallInstance = CMock_Guts_MemNext(Mock.flashWriteBlock_CallInstance);
  if (Mock.flashWriteBlock_IgnoreBool)
  {
    return;
  }
  if (Mock.flashWriteBlock_CallbackFunctionPointer != NULL)
  {
    Mock.flashWriteBlock_CallbackFunctionPointer(firstHalf, secondHalf, blockNumber, Mock.flashWriteBlock_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'flashWriteBlock' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashWriteBlock' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashWriteBlock' called later than expected.");
  if (cmock_call_instance->Expected_firstHalf == NULL)
    { UNITY_TEST_ASSERT_NULL(firstHalf, cmock_line, "Expected NULL. Function 'flashWriteBlock' called with unexpected value for argument 'firstHalf'."); }
  else
    { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_firstHalf, firstHalf, 1, cmock_line, "Function 'flashWriteBlock' called with unexpected value for argument 'firstHalf'."); }
  if (cmock_call_instance->Expected_secondHalf == NULL)
    { UNITY_TEST_ASSERT_NULL(secondHalf, cmock_line, "Expected NULL. Function 'flashWriteBlock' called with unexpected value for argument 'secondHalf'."); }
  else
    { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_secondHalf, secondHalf, 1, cmock_line, "Function 'flashWriteBlock' called with unexpected value for argument 'secondHalf'."); }
  UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_blockNumber, blockNumber, cmock_line, "Function 'flashWriteBlock' called with unexpected value for argument 'blockNumber'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_flashWriteBlock(CMOCK_flashWriteBlock_CALL_INSTANCE* cmock_call_instance, uint16* firstHalf, uint16* secondHalf, uint32 blockNumber)
{
  cmock_call_instance->Expected_firstHalf = firstHalf;
  cmock_call_instance->Expected_secondHalf = secondHalf;
  cmock_call_instance->Expected_blockNumber = blockNumber;
}

void flashWriteBlock_CMockIgnore(void)
{
  Mock.flashWriteBlock_IgnoreBool = (int)1;
}

void flashWriteBlock_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16* firstHalf, uint16* secondHalf, uint32 blockNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashWriteBlock_CALL_INSTANCE));
  CMOCK_flashWriteBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashWriteBlock_CallInstance = CMock_Guts_MemChain(Mock.flashWriteBlock_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashWriteBlock(cmock_call_instance, firstHalf, secondHalf, blockNumber);
}

void flashWriteBlock_StubWithCallback(CMOCK_flashWriteBlock_CALLBACK Callback)
{
  Mock.flashWriteBlock_CallbackFunctionPointer = Callback;
}

void flashWriteBlock_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint16* firstHalf, uint16* secondHalf, uint32 blockNumber, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashWriteBlock_CALL_INSTANCE));
  CMOCK_flashWriteBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashWriteBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashWriteBlock_CallInstance = CMock_Guts_MemChain(Mock.flashWriteBlock_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashWriteBlock(cmock_call_instance, firstHalf, secondHalf, blockNumber);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void flashReadBlock(uint16* data, uint16 size, uint32 blockNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_flashReadBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashReadBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.flashReadBlock_CallInstance);
  Mock.flashReadBlock_CallInstance = CMock_Guts_MemNext(Mock.flashReadBlock_CallInstance);
  if (Mock.flashReadBlock_IgnoreBool)
  {
    return;
  }
  if (Mock.flashReadBlock_CallbackFunctionPointer != NULL)
  {
    Mock.flashReadBlock_CallbackFunctionPointer(data, size, blockNumber, Mock.flashReadBlock_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'flashReadBlock' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashReadBlock' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'flashReadBlock' called later than expected.");
  if (cmock_call_instance->Expected_data == NULL)
    { UNITY_TEST_ASSERT_NULL(data, cmock_line, "Expected NULL. Function 'flashReadBlock' called with unexpected value for argument 'data'."); }
  else
    { UNITY_TEST_ASSERT_EQUAL_HEX16_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, "Function 'flashReadBlock' called with unexpected value for argument 'data'."); }
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_size, size, cmock_line, "Function 'flashReadBlock' called with unexpected value for argument 'size'.");
  UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_blockNumber, blockNumber, cmock_line, "Function 'flashReadBlock' called with unexpected value for argument 'blockNumber'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_flashReadBlock(CMOCK_flashReadBlock_CALL_INSTANCE* cmock_call_instance, uint16* data, uint16 size, uint32 blockNumber)
{
  cmock_call_instance->Expected_data = data;
  cmock_call_instance->Expected_size = size;
  cmock_call_instance->Expected_blockNumber = blockNumber;
}

void flashReadBlock_CMockIgnore(void)
{
  Mock.flashReadBlock_IgnoreBool = (int)1;
}

void flashReadBlock_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16* data, uint16 size, uint32 blockNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashReadBlock_CALL_INSTANCE));
  CMOCK_flashReadBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashReadBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashReadBlock_CallInstance = CMock_Guts_MemChain(Mock.flashReadBlock_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashReadBlock(cmock_call_instance, data, size, blockNumber);
}

void flashReadBlock_StubWithCallback(CMOCK_flashReadBlock_CALLBACK Callback)
{
  Mock.flashReadBlock_CallbackFunctionPointer = Callback;
}

void flashReadBlock_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint16* data, uint16 size, uint32 blockNumber, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_flashReadBlock_CALL_INSTANCE));
  CMOCK_flashReadBlock_CALL_INSTANCE* cmock_call_instance = (CMOCK_flashReadBlock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.flashReadBlock_CallInstance = CMock_Guts_MemChain(Mock.flashReadBlock_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_flashReadBlock(cmock_call_instance, data, size, blockNumber);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void rowErase(uint32 address)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_rowErase_CALL_INSTANCE* cmock_call_instance = (CMOCK_rowErase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.rowErase_CallInstance);
  Mock.rowErase_CallInstance = CMock_Guts_MemNext(Mock.rowErase_CallInstance);
  if (Mock.rowErase_IgnoreBool)
  {
    return;
  }
  if (Mock.rowErase_CallbackFunctionPointer != NULL)
  {
    Mock.rowErase_CallbackFunctionPointer(address, Mock.rowErase_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'rowErase' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'rowErase' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'rowErase' called later than expected.");
  UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_address, address, cmock_line, "Function 'rowErase' called with unexpected value for argument 'address'.");
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    Throw(cmock_call_instance->ExceptionToThrow);
  }
}

void CMockExpectParameters_rowErase(CMOCK_rowErase_CALL_INSTANCE* cmock_call_instance, uint32 address)
{
  cmock_call_instance->Expected_address = address;
}

void rowErase_CMockIgnore(void)
{
  Mock.rowErase_IgnoreBool = (int)1;
}

void rowErase_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32 address)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_rowErase_CALL_INSTANCE));
  CMOCK_rowErase_CALL_INSTANCE* cmock_call_instance = (CMOCK_rowErase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.rowErase_CallInstance = CMock_Guts_MemChain(Mock.rowErase_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_rowErase(cmock_call_instance, address);
}

void rowErase_StubWithCallback(CMOCK_rowErase_CALLBACK Callback)
{
  Mock.rowErase_CallbackFunctionPointer = Callback;
}

void rowErase_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, uint32 address, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_rowErase_CALL_INSTANCE));
  CMOCK_rowErase_CALL_INSTANCE* cmock_call_instance = (CMOCK_rowErase_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.rowErase_CallInstance = CMock_Guts_MemChain(Mock.rowErase_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  CMockExpectParameters_rowErase(cmock_call_instance, address);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

